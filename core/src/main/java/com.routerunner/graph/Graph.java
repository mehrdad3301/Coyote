package com.routerunner.graph;import com.routerunner.algorithms.LCC;import com.routerunner.geo.GeoMath;import com.routerunner.geo.Point;import java.util.ArrayList;import java.util.HashMap;/**Graph represents underlying road network. It uses an adjacency listto capture relations between nodes. Graph is undirected. */public class Graph {    int numEdges ;    int numNodes ;    ArrayList<ArrayList<Arc>> adjacencyList ;    ArrayList<Node> nodes ;    public Graph() {        this.numEdges = 0;        this.numNodes = 0 ;        this.nodes = new ArrayList<>();        this.adjacencyList = new ArrayList<>() ;    }    public void addNode(Node node) {        this.nodes.add(node) ;        this.numNodes += 1 ;    }    public void addEdge(int from, int to, int cost) {        if (nodes.size() < from || nodes.size() < to )            return ;        Arc arcTo = new Arc(to, cost) ;        Arc arcFrom = new Arc(from, cost) ;        while (adjacencyList.size() <= from ||                adjacencyList.size() <= to ) {            adjacencyList.add(new ArrayList<>()); }        this.adjacencyList.get(from).add(arcTo) ;        this.adjacencyList.get(to).add(arcFrom) ;        this.numEdges += 1 ;    }    public void removeEdge(int from, int to) {        adjacencyList.get(from).removeIf(arc -> arc.getHeadNodeId() == to);        adjacencyList.get(to).removeIf(arc -> arc.getHeadNodeId() == from);        this.numEdges -= 1 ;    }    public void removeNode(int id) {        ArrayList<Arc> arcsCopy = new ArrayList<>(adjacencyList.get(id)) ;        for (Arc arc: arcsCopy) {            removeEdge(id, arc.headNodeId) ;        }        adjacencyList.remove(id) ;        for (ArrayList<Arc> arcs : adjacencyList) {            for (Arc arc : arcs) {                int oldId = arc.getHeadNodeId();                if (oldId > id) {                    arc.headNodeId = oldId - 1 ;                }            }        }        nodes.remove(id) ;        numNodes -- ;    }    /**     * reduces the graph to a component identified by the given ids     * @param ids ids of the nodes that's going to get removed     */    public void reduceNodes(ArrayList<Integer> ids){        HashMap<Integer, Integer> oldToNewIds = new HashMap<>(ids.size()) ;        ArrayList<Node> newNodes = new ArrayList<>() ;        ArrayList<ArrayList<Arc>> newAdjList = new ArrayList<>() ;        for (int i = 0 ; i < ids.size() ; i ++ ) {            int id = ids.get(i) ;            oldToNewIds.put(id, i) ;            newNodes.add(nodes.get(id)) ;            newAdjList.add(adjacencyList.get(id)) ;        }       numEdges = 0 ;       for (ArrayList<Arc> arcs: newAdjList) {           for (Arc arc : arcs) {               arc.headNodeId = oldToNewIds.get(arc.headNodeId) ;               numEdges ++ ;           }       }       numEdges /= 2 ;       numNodes = newNodes.size() ;       adjacencyList = newAdjList ;       nodes = newNodes ;    }    public static Graph buildFromOSM(String fileAddress) throws Exception {        return new GraphBuilder(fileAddress).buildGraph() ;    }    public void reduceToLargestConnectedComponent() {        new LCC(this).reduceToLargestComponent();    }    @Override    public String toString() {        StringBuilder s = new StringBuilder("Graph{\n");        s.append("numEdges=").append(numEdges).append(",\n").                append("numNodes=").append(numNodes).append(",\n");        s.append("adjecency matrix= {\n");        for (int i = 0 ; i < adjacencyList.size() ; i++) {            s.append("\t").append(i).append("= {\n") ;            ArrayList<Arc> node = adjacencyList.get(i) ;            for (Arc arc : node) {                s.append("\t\t").append(arc.headNodeId).                        append(":").append(arc.cost).append("\n");            }            s.append("\n") ;        }        s.append("}");        return s.toString() ;    }    public int getNumNodes() {        return numNodes;    }    public int getNumEdges() {        return numEdges;    }    public ArrayList<Arc> getAdjacent(int id) {        return adjacencyList.get(id);    }    public Node getNode(int id) {        return nodes.get(id) ;    }    public boolean edgeExists(int from, int to, int cost) {        for (Arc arc: getAdjacent(from)) {            if (arc.getHeadNodeId() == to &&            arc.getCost() == cost)                return true  ;        }        return false ;    }    /**     * iterates over all the nodes in the graph and returns     * the closest one. An obvious and much more efficient approach     * would be to use a location index of some sort.     * @param point query point     * @return the closest node in the graph to query point     */    public int getClosestNode(Point point) {        double min = Integer.MAX_VALUE ;        int id = 0 ;        for (int i = 0 ; i < numNodes ; i++) {            double distance = GeoMath.getHaversineDistance(nodes.get(i).toPoint(), point) ;            if (distance < min) {                min = distance ;                id = i ;            }        }        return id ;    }}
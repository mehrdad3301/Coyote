package com.routerunner.graph;import com.routerunner.algorithms.LCC;import java.util.ArrayList;import static com.routerunner.util.Array.createMask;import static com.routerunner.util.Array.cumSum;/**Graph represents underlying road network. It uses an adjacency listto capture relations between nodes. Graph is undirected. */public class Graph {    int numEdges ;    int numNodes ;    ArrayList<ArrayList<Arc>> adjacencyList ;    ArrayList<Node> nodes ;    public Graph() {        this.numEdges = 0;        this.numNodes = 0 ;        this.nodes = new ArrayList<>();        this.adjacencyList = new ArrayList<>() ;    }    public void addNode(Node node) {        this.nodes.add(node) ;        this.numNodes += 1 ;    }    public void addEdge(int from, int to, int cost) {        if (nodes.size() < from || nodes.size() < to )            return ;        Arc arcTo = new Arc(to, cost) ;        Arc arcFrom = new Arc(from, cost) ;        this.adjacencyList.get(from).add(arcTo) ;        this.adjacencyList.get(to).add(arcFrom) ;        this.numEdges += 1 ;    }    public void removeEdge(int from, int to) {        adjacencyList.get(from).removeIf(arc -> arc.getHeadNodeId() == to);        adjacencyList.get(to).removeIf(arc -> arc.getHeadNodeId() == from);        this.numEdges -= 1 ;    }    public void removeNode(int id) {        ArrayList<Arc> arcsCopy = new ArrayList<>(adjacencyList.get(id)) ;        for (Arc arc: arcsCopy) {            removeEdge(id, arc.headNodeId) ;        }        adjacencyList.remove(id) ;        for (ArrayList<Arc> arcs : adjacencyList) {            for (Arc arc : arcs) {                int oldId = arc.getHeadNodeId();                if (oldId > id) {                    arc.headNodeId = oldId - 1 ;                }            }        }        nodes.remove(id) ;        numNodes -- ;    }    public void removeNodes(ArrayList<Integer> ids){        ArrayList<Node> newNodes = new ArrayList<>() ;        ArrayList<ArrayList<Arc>> newAdjList = new ArrayList<>() ;        for (Integer i : ids) {            newNodes.add(nodes.get(i)) ;            newAdjList.add(adjacencyList.get(i)) ;        }       ArrayList<Integer> sum = cumSum(createMask(ids, numNodes)) ;       numEdges = 0 ;       for (ArrayList<Arc> arcs: newAdjList) {           for (Arc arc : arcs) {               arc.headNodeId = sum.get(arc.headNodeId) - 1 ;               numEdges ++ ;           }       }       numEdges /= 2 ;       numNodes = newNodes.size() ;       adjacencyList = newAdjList ;       nodes = newNodes ;    }    public static Graph buildFromOSM(String fileAddress) throws Exception {        return new GraphBuilder(fileAddress).buildGraph() ;    }    public void reduceToLargestConnectedComponent() {        new LCC(this).reduceToLargestComponent();    }    @Override    public String toString() {        StringBuilder s = new StringBuilder("Graph{\n");        s.append("numEdges=").append(numEdges).append(",\n").                append("numNodes=").append(numNodes).append(",\n");        s.append("adjecency matrix= {\n");        for (int i = 0 ; i < adjacencyList.size() ; i++) {            s.append("\t").append(i).append("= {\n") ;            ArrayList<Arc> node = adjacencyList.get(i) ;            for (Arc arc : node) {                s.append("\t\t").append(arc.headNodeId).                        append(":").append(arc.cost).append("\n");            }            s.append("\n") ;        }        s.append("}");        return s.toString() ;    }    public int getNumEdges() {        return numEdges;    }    public int getNumNodes() {        return numNodes;    }    public ArrayList<Arc> getAdjacent(int id) {        return adjacencyList.get(id);    }    public Node getNode(int id) {        return nodes.get(id) ;    }}
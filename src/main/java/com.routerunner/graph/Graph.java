package main.java.com.routerunner.graph;import main.java.com.routerunner.algorithms.LCC;import java.util.ArrayList;/**Graph represents underlying road network. It uses an adjacency listto capture relations between nodes. Graph is undirected. */public class Graph {    int numEdges ;    int numNodes ;    final ArrayList<ArrayList<Arc>> adjacencyList ;    ArrayList<Node> nodes ;    public Graph() {        this.numEdges = 0;        this.numNodes = 0 ;        this.nodes = new ArrayList<>();        this.adjacencyList = new ArrayList<>();    }    public void addNode(Node node) {        this.nodes.add(node) ;        this.numNodes += 1 ;    }    public void addEdge(int from, int to, int cost) {        if (nodes.size() < from || nodes.size() < to )            return ;        Arc arcTo = new Arc(to, cost) ;        Arc arcFrom = new Arc(from, cost) ;        this.adjacencyList.get(from).add(arcTo) ;        this.adjacencyList.get(to).add(arcFrom) ;        this.numEdges += 1 ;    }    public void removeEdge(int from, int to) {        adjacencyList.get(from).removeIf(arc -> arc.getHeadNodeId() == to);        adjacencyList.get(to).removeIf(arc -> arc.getHeadNodeId() == from);        this.numEdges -= 1 ;    }    public void removeNode(int id) {        ArrayList<Arc> arcsCopy = new ArrayList<>(adjacencyList.get(id)) ;        for (Arc arc: arcsCopy) {            removeEdge(id, arc.headNodeId) ;        }        adjacencyList.remove(id) ;        for (ArrayList<Arc> arcs : adjacencyList) {            for (Arc arc : arcs) {                int oldId = arc.getHeadNodeId();                if (oldId > id) {                    arc.headNodeId = oldId - 1 ;                }            }        }        nodes.remove(id) ;        numNodes -- ;    }    /**     * a more efficient way of removing nodes, when they are large.     * please note that ids must be given in increasing order !     */    public void removeNodes(ArrayList<Integer> ids) {        nodes.removeAll(ids) ;        for (int i = ids.size() - 1 ; i >= 0 ; i --) {            nodes.remove((int) ids.get(i)) ;            adjacencyList.remove((int) ids.get(i)) ;        }       ArrayList<Integer> sum = new ArrayList<>(numNodes + 1) ;       sum.add(0) ;       int j = 0 ;       for (int i = 1 ; i < numNodes + 1 ; i ++) {          if (j >= ids.size()) {              sum.add(sum.get(i - 1));              continue ;          }          if (i < ids.get(j)) {              sum.add(sum.get(i - 1));          } else {              sum.add(sum.get(i - 1) + 1) ;              j++ ;          }       }       numEdges = 0 ;       for (ArrayList<Arc> arcs: adjacencyList) {           for (Arc arc : arcs) {               arc.headNodeId -= sum.get(arc.headNodeId + 1) ;               numEdges ++ ;           }       }       numNodes -= ids.size() ;    }    public static Graph buildFromOSM(String fileAddress) throws Exception {        return new GraphBuilder(fileAddress).buildGraph() ;    }    public void reduceToLargestConnectedComponent() {        new LCC(this).reduceToLargestComponent();    }    @Override    public String toString() {        StringBuilder s = new StringBuilder("Graph{\n");        s.append("numEdges=").append(numEdges).append(",\n").                append("numNodes=").append(numNodes).append(",\n");        s.append("adjecency matrix= {\n");        for (int i = 0 ; i < adjacencyList.size() ; i++) {            s.append("\t").append(i).append("= {\n") ;            ArrayList<Arc> node = adjacencyList.get(i) ;            for (Arc arc : node) {                s.append("\t\t").append(arc.headNodeId).                        append(":").append(arc.cost).append("\n");            }            s.append("\n") ;        }        s.append("}");        return s.toString() ;    }    public int getNumEdges() {        return numEdges;    }    public int getNumNodes() {        return numNodes;    }    public ArrayList<Arc> getAdjacent(int id) {        return adjacencyList.get(id);    }}